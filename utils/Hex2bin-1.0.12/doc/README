Yet Another Hex to bin converter

It can handle the extended Intel hex format in segmented and linear address
modes. Records need not be sorted and there can be gaps between records.

Some hex files are produced by compilers. They generate objects files for each
module in a project, and when the linker generates the final hex file, the
object files are stored within the hex files, but modules can appear not
necessary in order of address.

How does it work?

Hex2bin/mot2bin allocates a 4 MBytes buffer and just place the converted bytes
in its buffer. At the end, the buffer is written to disk. Using a buffer elimi-
nates the need to sort records.  If the option l is used (3), the buffer will be
allocated with the maximum size specified if over 4Mbytes.

Before reading the hex file, the buffer is filled with a default value. These
padding bytes are all FF by default so an EPROM programmer can skip these bytes
when programming. The padding value can be changed with the -p option.

1. Compiling on Linux or other unix platforms

	make

	then

	make install

	This will install the program to /usr/local/bin.

1a. Compiling for Windows on Msys, Cygwin or DOS prompt

	The programs can be compiled as follows:
	  gcc -O2 -Wall -o hex2bin.exe hex2bin.c
	  gcc -O2 -Wall -o mot2bin.exe mot2bin.c

2. Using hex2bin

	hex2bin example.hex

	hex2bin will generate a binary file example.bin starting at the
	lowest address in the hex file.

3. Starting Address and Length

	If the lowest address isn't 0000,
	    ex: 0100: (the first record begins with :nn010000xxx )

	there will be problems when using the binary file to program a EPROM
	since the first byte supposed to be at 0100 is stored in the binary file
	at 0000.

	you can specify a starting address on the command line:

	hex2bin -s 0000 start_at_0100.hex

		This start address is not the same thing as the start address record in
		the hex file. The start address record is used to specify the starting
		address for execution of the binary code.

	The bytes will be stored in the binary file with a padding from 0000
	to the lowest address minus 1 (00FF in this case).

	Similarly, the binary file can be padded up to Length -1 with FF or another byte.

	Here, the space between the last byte and 07FF will be filled with FF.
	hex2bin -l 0800 ends_before_07FF.hex

	EPROM, EEPROM and Flash memories contain all FF when erased.

	This program does minimal error checking since many hex files are
	generated by known good assemblers.

	When the source file name is
		for-example.test.hex
	the binary created will have the name
		for-example.bin
	the ".test" part will be dropped.

	Hex2bin/mot2bin assume the source file doesn't contain overlapping records,
	if so, overlaps will be reported.

4. Checksum of source file

	By default, it ignores checksum errors, so that someone can change
	by hand some bytes allowing quick and dirty changes.
	If you want checksum error reporting, specify the option -c.

	hex2bin -c example.hex

	If there is a checksum error somewhere, the program will continue the
	conversion anyway.

	The example file example.hex contains some records with checksum errors.

5. Checksum inserted inside binary file

	A checksum value can be inserted in the resulting binary file.

	hex2bin -k [0|1|2] -r [start] [end] -f [address] [value]

	-k  Select checksum type:

		0 = 8-bit checksum
		1 = 16-bit checksum, little endian
		2 = 16-bit checskum, big endian

    -r	Range to compute checksum over (default is min and max addresses)

    -f	Address and value of checksum to force

6. Motorola S files

	mot2bin example.s19

	Options for mot2bin are the same as hex2bin. Executing the program
	without argument will display available options. Some are specific to
	Motorola files.

	This program will handle S19 files generated for Motorola micropro-
	cessors. Since I use this program for an EPROM programmer, I will
	rarely need to have more than 4M, I limited the source program for
	24 bits or 16 bits address records.

	32 bits records are now supported, but obviously I can't allocate all
	the memory for the binary target. What I did is simply assume that the
	binary file will occupy less than 4M. For binary files greater than 4M,
	see length option (section 3).

7. Support for byte-swapped hex/S19 files

    -w	Wordwise swap: for each pair of bytes, exchange the low and high part.
	If a checksum needs to be generated to insert in the binary file, select
	one of the 16-bit checksums.

	hex2bin -w test-byte-swap.hex

8. Goodies

	Description of the file formats is included.
	Added examples files for extended addressing.

	Check for overlapping records. The check is rather basic: supposing
	that the buffer is filled with pad bytes, when a record overlaps a
	previous one, value in the buffer will be different from the pad bytes.
	This will not detect the case when the previous value equals the pad byte,
	but it's more likely that more than one byte will be overlapped.


9. Error messages

	"0 byte length data record ignored"

	This means that an empty data record was read. Since it's empty, it's simply
	ignored and should have no impact on the binary file.

	"Data record skipped at ..."

	This means that the records are falling outside the memory buffer. Hex2bin/
	mot2bin use a 4Mi memory buffer size. You may try to increase the buffer
	size by specifying a maximum length of 8Mi or higher; see length option
	(section 3).

	"Overlapped record detected"

	A record is overwritten by a subsequent record. If you're using SDCC, check
	if more than one area is specified with a starting address. Checking the map
	file generated by the linker can help.

10. History

        See ChangeLog

11. Other hex tool

	There is a program that supports more formats and has more features.
	See SRecord at http://srecord.sourceforge.net/
